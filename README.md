# Лабораторная работа №4

---

- Выполнил: Назин Артем Аркадьевич, P3207
- `asm | acc | harv | hw | tick | binary | trap | mem | cstr | prob2 | vector`

## Язык программирования

### Синтаксис

Расширенная форма Бэкуса-Наура:

```ebnf
program ::= <data_sec>? <text_sec> <int_sec> | <text_sec> <int_sec> 

<data_sec> ::= <s_all> ".section" <s_plus> "data" <s_all> "\n" (<org> | <data_decl> | <lbl_str> | <empty>)*
<text_sec> ::= <s_all> ".section" <s_plus> "text" <s_all> "\n" (<org> | <cmd> | <lbl_str> | <empty>)*
<int_sec>  ::= <s_all> ".section" <s_plus> "int"  <s_all> "\n" (<org> | <cmd> | <ret> | <lbl_str> | <empty>)*

<s_all>  ::= ("\t" | " ")*
<s_plus> ::= ("\t" | " ")+
<empty> ::= <s_all> "\n"

<org> ::= <s_all> ".org" <s_plus> (<hex> | <pos_dec> | <zero>) <s_all> "\n"

<data_decl> ::= <s_all> (<lbl_data_decl> | <no_lbl_data_decl>) <s_all> "\n"
<lbl_data_decl> ::= <label_decl> <s_plus> <no_lbl_data_decl>
<no_lbl_data_decl> ::= <data_type> <s_plus> <data> 
<data_type> ::= ".word" | ".byte"
<data> ::= <data> <s_plus> <data> | <hex> | <dec> | <str> | <label>

<hex> ::= "0x[a-f0-9]{1,6}"
<dec> ::= <pos_dec> | <neg_dec> | <zero>
<neg_dec> ::= "-" <pos_dec>
<pos_dec> ::= [1, 2^31-1]
<zero> ::= "0"

<str> ::= "'\w+'"
<label_decl> ::= "\w+:"
<label> ::= "\w+"
<lbl_str> ::= <s_all> <label_decl> <s_all> "\n"

<ret> ::= <s_all> "ret" <s_all> "\n"
<cmd> ::= <s_all> (<lbl_cmd>|<no_lbl_cmd>) <s_all> "\n"
<lbl_cmd> ::= <label_decl> <s_plus> <no_lbl_cmd>
<no_lbl_cmd> ::= <mnemonik> | <mnemonik> <s_plus> <cmd_op> 
<cmd_op> ::= <label> | <dec> | <hex> | <lit> 

<lit> ::= "'\w'"
<mnemonik> ::= "inc" | "dec" | "inc4" | "dec4" | "inc" | "neg" | "halt" 
| "ld" | "add" | "sub" | "and" | "or" | "xor" | "shiftl" | "shiftr" | "mul" | "div" 
| "rem" | "ld_a" | "add_a" | "sub_a" | "and_a" | "or_a" | "xor_a" | "shiftl_a"  
| "shiftr_a" | "mul_a" | "div_a" | "rem_a" | "jmp" | "jz" | "jnz" | "jgt" 
| "jlt"  | "jc" | "jnc" | "jv" | "jnvr" | "st" | "ld_ind" | "st_ind" | "jzr" 
| "jnzr" | "jgtr" | "jltr" | "jcr" | "jncr" | "jvr" | "jnvr"

```

### Семантика

- `ld <cmd_op>`  -- загрузить значение непосредственно (immediate) в AC
- `add <cmd_op>` -- сложить значение из AC и указанное значение и защелкнуть в AC
- `sub <cmd_op>` -- вычесть из AC указанное значение 
- `and <cmd_op>` -- побитовое И значения из AC и указанного значения
- `or <cmd_op>`  -- побитовое ИЛИ значения из AC и указанного значения
- `xor <cmd_op>` -- побитовое Исключающее ИЛИ значения из AC и указанного значения
- `shiftl <cmd_op>` -- логический сдвиг AC влево на указанное значение бит 
- `shiftr <cmd_op>` -- логический сдвиг AC вправо на указанное значение бит 
- `mul <cmd_op>` -- умножить AC на указанное значение 
- `div <cmd_op>` -- целочисленно поделить AC на указанное значение 
- `rem <cmd_op>` -- защелкнуть в AC остаток от деления значения AC на указанное значение 
- `add_a <cmd_op>`, `sub_a <cmd_op>`, `and_a <cmd_op>`, `or_a <cmd_op>`, 
`xor_a <cmd_op>`, `shiftl_a <cmd_op>`, `shiftr_a <cmd_op>`, `mul_a <cmd_op>`, 
`div_a <cmd_op>`, `rem_a <cmd_op>` -- аналогично предыдущей семантике, 
но вместо непосредственного значения (immediate) берется значение `mem[<cmd_op>]`
- `jmp <cmd_op>` -- изменяет значение регистра PC на указанное значение
- `jz <cmd_op>` -- изменяет значение регистра PC на указанное значение если установлен флаг `Z`
- `jnz <cmd_op>` -- изменяет значение регистра PC на указанное значение если не установлен флаг `Z`
- `jgt <cmd_op>` -- изменяет значение регистра PC на указанное значение если не установлен флаг `N`
- `jlt <cmd_op>` -- изменяет значение регистра PC на указанное значение если установлен флаг `N`
- `jc <cmd_op>` -- изменяет значение регистра PC на указанное значение если установлен флаг `C`
- `jnc <cmd_op>` -- изменяет значение регистра PC на указанное значение если не установлен флаг `C`
- `jv <cmd_op>` -- изменяет значение регистра PC на указанное значение если установлен флаг `V`
- `jnv <cmd_op>` -- изменяет значение регистра PC на указанное значение если не установлен флаг `V`
- `jr <cmd_op>`, `jzr <cmd_op>`, `jnzr <cmd_op>`, `jgtr <cmd_op>`, `jltr <cmd_op>`, 
`jcr <cmd_op>`, `jcnr <cmd_op>`, `jvr <cmd_op>`, `jnvr <cmd_op>` -- аналогично предыдущей семантике, 
но вместо непосредственного значения (immediate) для PC берется значение `PC+<cmd_op>`. <b>Важно:</b> в данном случае `<cmd_op>` кодируется 2 байтами 
- `inc` -- инкрементирует значение AC на 1
- `inc4` -- инкрементирует значение AC на 4
- `dec` -- декрементирует значение AC на 1
- `dec4` -- декрементирует значение AC на 4
- `neg` -- защелкивает в AC значение AC с противоположным знаком
- `inv` -- защелкивает в AC значение побитого НЕ значения AC
- `halt` -- завершает работу (останавливает тактовый генератор)
- `ret` -- возврат из прерывания, восстанавливает прежнее значения PC (до прерывания)

### Особенности реализации

- Значение меток в памяти команд и памяти данных могут быть использованы как операнд в любой из команд, но это может быть бесполезно, так как механизм для передачи данных из памяти данных в память команд и наоборот 
не предусмотрен. 
- В программе не может быть дублирование меток.
- В текущей реализации не допускаются пробельные символы в строковых значениях. Необходимо явно указывать их код в `ascii`.
- В текущей реализации не предусмотрены комментарии.
- Допускается располагать секции программы в произвольном порядке и разбивать их на части, но программа обязательна 
должна содержать секции `int` и `text`
- Исполнение кода секции `text` начинается с метки `start`, а секции `int` с первой указанной команды.
- Строковые литералы упаковываются побайтово 
- Метки могут располагаться на отдельных строках и захватят первый адрес написанной далее команды или объявления данных.

### Порядок выполнения

Программа выполняется последовательно, одна инструкция за другой. 
При возникновении прерывания (если оно разрешено) программа переходит на исполнение кода секции `int` 

### Память

- Распределяется статически на этапе трансляции
- Память команд (cmem) содержит в себе данные секций `text` и `int`. 
Память данных (mem) содержит в себе данные секции `data`
### Области видимости

Все данные расположены в одной глобальной области видимости.

### Типизация, виды литералов

В языке определены четыре вида литералов:

- Строковые
- Целочисленные
- Шестнадцатеричные
- Метки 

Любые данные могут быть интерпретированы по-разному в зависимости от потребностей программиста.
Но данные типизированы по их размеру: `.word`, `.byte`, `.hword` \
(данные типа `.hword` (пол машинного слова) не могут быть объявлены и должны быть использованы только в серии команд 
`j*r` как непосредственные значения) 

## Организация памяти

- Гарвардская архитектура
- Размер машинного слова:

    - Память команд: 32 бита
    - Память данных: 40 бита

- Имеет линейное адресное пространство
- В памяти данных хранятся данные и переменные объявленные в секции `data`
- В памяти команд хранятся инструкции для выполнения (секций `text` и `int`)
- Взаимодействие с памятью данных происходит через инструкции серии `*_a`, `st`, `ld_ind`, `st_ind`
- Виды адресации:
    - Абсолютная
    - Относительная
    - Косвенная

- Адресация выполняется побайтово
- Данные в памяти хранятся в формате Big-endian
- Блоки данных, массивы или строки упаковываются в память данных непосредственно друг за другом и их размер 
соответствует их типу данных (`.byte`, `.word`)
- Все переменные отображаются в память на этапе трансляции
- Запись в память команд по время исполнения не предусмотрена 
- Адреса 0x20 и 0x21 памяти данных являются портами ввода-вывода и запрещены для ряда операций
- При компиляции программы в память команд по адресам 0-4 помещается `jmp start`. 
А по адресам 5-9 помещается `jmp {int}`, где `{int}` - первый адрес секции `int`

```plaintext
          Data memory
+------------------------------+
|    ...                       |
| 20  : input cell             |
| 21  : output cell            |
|    ...                       |
+------------------------------+
          Command memory
+------------------------------+
| 0-5 : jmp start              |
| 6-9 : jmp {int}              |
|    ...                       |
+------------------------------+
```

### Регистры

В модели присутствуют следующие регистры:

- `ac` -- аккумулятор
- `cr` -- регистр для хранения текущей исполняемой команды 
- `pc` -- регистр для нужен адресации по памяти команд
- `ar` -- регистр для нужен адресации по памяти данных
- `flg` -- регистр, что содержит флаги АЛУ
- `ra` -- регистр для сохранения `pc` во время исполнения прерывания
## Система команд

### Особенности процессора

- Устройство ввода-вывода: `memory-mapped`, ввод и вывод привязаны к портам `0x20` и `0x21` памяти данных
  соответственно
- Ввод осуществляется по программному прерыванию с запуском кода секции `int`
- Прерывание происходит перед исполнением новой инструкции (статус `CUState.PreStart`)
- Прерывание разрешено если выполняются три условия: сейчас не обрабатывается прерывание И не прерывание уже запрошено 
И сейчас не исполняются векторные операции
- При исполнении секции `int` необходимо явно куда-то в память данных сохранить значение `ac`

### Набор инструкций

| opcode | Мнемоника          | Число тактов | Описание                |
|:-------|:-------------------|:-------------|:------------------------|
| `01`   | `inc`              | 1            | `ac <- ac+1`            |
| `02`   | `dec`              | 1            | `ac <- ac-1`            |
| `03`   | `inc4`             | 1            | `ac <- ac+4`            |
| `04`   | `dec4`             | 1            | `ac <- ac-4`            |
| `05`   | `inv`              | 1            | `ac <- ~ac`             |
| `06`   | `neg`              | 1            | `ac <- -ac`             |
| `07`   | `halt`             | 1            | `halt`                  |
| `08`   | `ret`              | 1            | `pc <- ra`              |
| `40`   | `ld_imm [op]`      | 1            | `ac <- op`              |
| `41`   | `add_imm [op]`     | 1            | `ac <- ac+op`           |
| `42`   | `sub_imm [op]`     | 1            | `ac <- ac-op`           |
| `43`   | `and_imm [op]`     | 1            | `ac <- ac&op`           |
| `44`   | `or_imm [op]`      | 1            | `ac <- ac\|op`          |
| `45`   | `xor_imm [op]`     | 1            | `ac <- ac^op`           |
| `46`   | `shiftl_imm [op]`  | 1            | `ac <- ac << op`        |
| `47`   | `shiftr_imm [op]`  | 1            | `ac <- ac >> op`        |
| `48`   | `mul_imm [op]`     | 1            | `ac <- ac * op`         |
| `49`   | `div_imm [op]`     | 1            | `ac <- ac // op`        |
| `4A`   | `rem_imm [op]`     | 1            | `ac <- ac % op`         |
| `4B`   | `jmp [op]`         | 1            | `pc <- op`              |
| `4C`   | `jz [op]`          | 1            | `pc <- op if z==1`      |
| `4D`   | `jnz [op]`         | 1            | `pc <- op if z==0`      |
| `4E`   | `jgt [op]`         | 1            | `pc <- op if n==0`      |
| `4F`   | `jlt [op]`         | 1            | `pc <- op if n==1`      |
| `50`   | `jc [op]`          | 1            | `pc <- op if c==1`      |
| `51`   | `jnc [op]`         | 1            | `pc <- op if c==0`      |
| `52`   | `jv [op]`          | 1            | `pc <- op if v==1`      |
| `53`   | `jnv [op]`         | 1            | `pc <- op if v==0`      |
| `60`   | `ld_addr [op]`     | 2            | `ac <- mem[op]`         |
| `61`   | `add_addr [op]`    | 2            | `ac <- ac+mem[op]`      |
| `62`   | `sub_addr [op]`    | 2            | `ac <- ac-mem[op]`      |
| `63`   | `and_addr [op]`    | 2            | `ac <- ac&mem[op]`      |
| `64`   | `or_addr [op]`     | 2            | `ac <- ac\|mem[op]`     |
| `65`   | `xor_addr[op]`     | 2            | `ac <- ac^mem[op]`      |
| `66`   | `shiftl_addr [op]` | 2            | `ac <- ac << mem[op]`   |
| `67`   | `shiftr_addr [op]` | 2            | `ac <- ac >> mem[op]`   |
| `68`   | `mul_addr [op]`    | 2            | `ac <- ac * mem[op]`    |
| `69`   | `div_addr [op]`    | 2            | `ac <- ac // mem[op]`   |
| `6A`   | `rem_addr [op]`    | 2            | `ac <- ac % mem[op]`    |
| `6B`   | `st_addr [op]`     | 1            | `mem[op] <- ac`         |
| `6C`   | `ld_ind [op]`      | 4            | `ac <- mem[mem[op]]`    |
| `6D`   | `st_ind [op]`      | 3            | `mem[mem[op]] <- ac`    |
| `80`   | `jz_r [op]`        | 1            | `pc <- op+pc if z==1`   |
| `81`   | `jnz_r [op]`       | 1            | `pc <- op+pc if z==0`   |
| `82`   | `jgt_r [op]`       | 1            | `pc <- op+pc if n==0`   |
| `83`   | `jlt_r [op]`       | 1            | `pc <- op+pc if n==1`   |
| `84`   | `jc_r [op]`        | 1            | `pc <- op+pc if c==1`   |
| `85`   | `jnc_r [op]`       | 1            | `pc <- op+pc if c==0`   |
| `86`   | `jv_r [op]`        | 1            | `pc <- op+pc if v==1`   |
| `87`   | `jnv_r [op]`       | 1            | `pc <- op+pc if v==0`   |
| `88`   | `jmp_r [op]`       | 1            | `pc <- op+pc`           |


### Способ кодирования инструкций

Инструкции могут быть разного размера: 1,3,5 байт. Первый байт - код операции, 
остальное - операнд. В регистр `cr` сразу загружается 5 байт: `cmem[pc:pc+4]` 

Имеется 4 вида инструкций по типу операнда:

1. Без операнда
2. Операнд с прямой загрузкой (4 байта)
3. Операнд - адрес (4 байта)
4. Операнд - относительный адрес (2 байта)
#### Бинарное представление

Кодирование этих инструкций происходит следующим образом:

```plaintext
┌─────┬──────────┬──────────┬───────────┬────────────┐
│ тип │   0..1   │   2..7   │   8..23   │   24..39   │
├─────┼──────────┼──────────┼───────────┴────────────┘
│  1  │    00    │  xxxxxx  │  
├─────┼──────────┼──────────┼────────────────────────┐
│  2  │    01    │  0xxxxx  │        operand         │
├─────┼──────────┼──────────┼────────────────────────┤
│  3  │    01    │  1xxxxx  │        operand         │
├─────┼──────────┼──────────┼───────────┬────────────┘
│  4  │    10    │  xxxxxx  │  operand  │
└─────┴──────────┴──────────┴───────────┘
```
Где `x` - биты кода операции 

#### Формат инструкций

- Машинный код "компилируется" в бинарные файлы `.cmem` и `.mem`
- Внутри бинарных файлов непосредственно располагаются данные по такому адресу, по которому они будут загружены. 
Размер файла (и, соответственно, статически загружаемой памяти) может быть указан при компиляции (трансляции)

Пример:
![no photo](./imgs/bin.png)


